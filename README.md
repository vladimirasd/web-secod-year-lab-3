Ответы на вопросы из защиты:

1.Управляемые бины - назначение, способы конфигурации. Контекст управляемых бинов:
  //Бины могут взаимодействовать друг с другом только через DI.
  //Всем жизненным циклом бинов руководит runtim, поэтому обращаться к бинам тоже можно только через runtime, то есть как раз через DI.
  //Инъекции однонаправленные, то есть в иерархии бинов старшие бины не могут обращаться к младшим.
  Контекс (scope):
    1) @NoneScoped - изначально без контекста, урплавляется другими бинами. То есть такой бин инжектится (DI - внедрение зависимостей) в другой бин и принимает его скоуп.
    2) @RequestScope - время жизни = HttpRequest. По дефолту у всех бинов он такой.
    3) @ViewScoped - время жизни = страница, то есть до момента перезагрузки страницы.
    4) @SessionScoped - время жизни = сессия.
    5) @AppliocationScoped - время жизни = работа контейнера.
    6) @CustomScoped - время жизни определяется разработчик. Есть специальная Map, в котором живет этот бин, и уже непосредсвтенно в runtime этот бин в произвольный момент времени может быть уничтожен или создан.
  Способы конфигруации:
    1) Аннотации:
      1)@ManagedBean - имя бина внутри
      2)@FooScoped - показал все выше
      3)@ManagedProperty - присовить свойству бина с именем из name значение из value. DI в аннотациях.
    2) face-config.xml:
      Параметры для конфига:
        1) managed-bean-name
        2) managed-bean-class
        3) managed-bean-scope
        4) managed-propetry, как раз таки DI, то есть присовить свойству бина из property-name присвоить значение из value
  El - способ доступа к управляемым бинам #{bin-name.bin-property} - трансилируется в вызов геттера или сеттера. При этом можно использовать и  ${bin-name.bin-property}, но это readonly:
    1) value = получаение значений
    2) validator = биндинг функции для валидации.
    3) binding = чем-то похоже на value, но работает через другую фазу JSF runtime.
    4) action = ссылка на исполняемый метод
  Конверторы - служат для преобразования текста ( чем как раз таки HTTP и обменивается) , в Java-объекты:
    1) Реалзует интрейфейс Convertor, так что можно писать свои.
    2) Существуют стандартные для всех основных типов данных.
