Для докера
Если нет постргреса перед этим выполните docker pull postgres
docker run -p 5432:5432 -d --name db -e POSTGRES_PASSWORD=ваш_пароль -e POSTGRES_DB=имя_вашей_дб postgres

Ответы на вопросы из защиты:
1.Технология JavaServer Faces. Особенности, отличия от сервлетов и JSP, преимущества и недостатки. Структура JSF-приложения:
  1) JSF - фреймворд для разработки веб приложений, входящий в состав Java EE и основанный на использовании комнонентов. Для отображения используется JSP и facelets.
  2) Достоинства и недостатки:
     +) Четнок разделение бизнес-логики и представления( как раз таки разделение facelets и бинов, MVC)
     +) Управление обменов данных на уровне компонентов, потому что приложение пишется в desktop стиле, то есть по сути всю страницу можно написать вообще без JS, компоненты их эвенты и обработчики валидаторы и конверторы указываются явно в xml (легкий и понятный API для использования ajax для доступа к бинам)
     +) Простая работа с событиями на стороне сервера, то есть событийная парадигма.
     +) Несколько реализаций
     +) Расширяемость ( IceFaces, PrimeFaces
     -) Высокий уровень абстракции(сложно сделать что-то нестандратное)
     -) Сложность разработчки своих комнонетов, сложная и большая сепцификация
  3) Структура JSF приложений:
     1. JSP и XTHML страницы
     2. Библиотеки тегов
     3. Управляемые бины
     4. Дополнительные объекты ( валидаторы, конверторы и отдельные компоненты)
     5. Дополнительные теги
     6. Конфиг faces-congif, можно просто юзать аннотации
     7. Дескриптор развертывания web.xml
2.Использование JSP-страниц и Facelets-шаблонов в JSF-приложениях:
3.JSF-компоненты - особенности реализации, иерархия классов. Дополнительные библиотеки компонентов. Модель обработки событий в JSF-приложениях:
    Компоненты:
        1)Интерфейс строится из компонентов, каждый компоненты = html на фронте + java код на беке.
        2)Все компоненты реализуют базовый интрефейс UIComponent
        3)Расположены либо на jsp либо на facelets
        4)Можно создавать свои комопоненты
        5)Все компоненты на странице объеденины в единое дерево, называемое представлением, корнем которого является класс UIViewRoot
        6)По сути сущетсвует два DOM, на фронте и беке, и FacesServlet синхранизует их.
    Иерархия:
        1) StateHolder (interface). boolean isTransiet() void restoreState() Object saveState() void setTransiet()
        2) <- UIComponent (abs class)
        3)  <- UIComponentBase <- все отсальное 
4.Конвертеры и валидаторы данных:
    Конверторы - служат для преобразования текста ( чем как раз таки HTTP и обменивается) , в Java-объекты:
      1) Реалзует интрейфейс Convertor, так что можно писать свои.
      2) Существуют стандартные для всех основных типов данных.
      3) В компонентах либо задаются автоматически либо акзываются в специальном теге / атрибуте
    Валидаторы:
      1) Исполняются после конвертора но до обновления модели.
      2) Реализуют интерфейс Validator
      3) Существуют стандартные, которые можно указывать либо в атрибутах тегов либо в аннотациях полей.
3.Управляемые бины - назначение, способы конфигурации. Контекст управляемых бинов:
  //Бины могут взаимодействовать друг с другом только через DI.
  //Всем жизненным циклом бинов руководит runtime, поэтому обращаться к бинам тоже можно только через runtime, то есть как раз через DI.
  //Инъекции однонаправленные, то есть в иерархии бинов старшие бины не могут обращаться к младшим.
  Контекс (scope):
    1) @NoneScoped - изначально без контекста, урплавляется другими бинами. То есть такой бин инжектится (DI - внедрение зависимостей) в другой бин и принимает его скоуп.
    2) @RequestScope - время жизни = HttpRequest. По дефолту у всех бинов он такой.
    3) @ViewScoped - время жизни = страница, то есть до момента перезагрузки страницы.
    4) @SessionScoped - время жизни = сессия.
    5) @AppliocationScoped - время жизни = работа контейнера.
    6) @CustomScoped - время жизни определяется разработчик. Есть специальная Map, в котором живет этот бин, и уже непосредсвтенно в runtime этот бин в произвольный момент времени может быть уничтожен или создан.
  Способы конфигруации:
    1) Аннотации:
      1)@ManagedBean - имя бина внутри
      2)@FooScoped - показал все выше
      3)@ManagedProperty - присовить свойству бина с именем из name значение из value. DI в аннотациях.
    2) face-config.xml:
      Параметры для конфига:
        1) managed-bean-name
        2) managed-bean-class
        3) managed-bean-scope
        4) managed-propetry, как раз таки DI, то есть присовить свойству бина из property-name присвоить значение из value
  El - способ доступа к управляемым бинам #{bin-name.bin-property} - трансилируется в вызов геттера или сеттера. При этом можно использовать и  ${bin-name.bin-property}, но это readonly:
    1) value = получаение значений
    2) validator = биндинг функции для валидации.
    3) binding = чем-то похоже на value, но работает через другую фазу JSF runtime.
    4) action = ссылка на исполняемый метод
7.Конфигурация JSF-приложений. Файл faces-config.xml. Класс FacesServlet.
  FacesServlet - controller в MVC. Обрабатывает запросы браузера, формирует объекты-события и вызывает методы-слушатели.
  Конфигурация как и у любого сервлета задается в web.xml. По сути сущетсвует два DOM, на фронте и беке, и FacesServlet синхранизует их.
8. Навигация в JSF-приложениях.
  1) Реализуется экземпляром классом NavigationHandler, писать его не надо, она автоматически создается на основе navigation rule
  2) Правила задаются в faces-config:
       <from-view-id> - откуда идем
       <navigation-case> - куда можем прийти
       <from-outcome> - при каком значении. Можно задавать в button или как return метода из action в commandButton.
       <to-view-id> куда придем

